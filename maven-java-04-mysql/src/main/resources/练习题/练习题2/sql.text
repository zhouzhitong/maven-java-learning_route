# 1、查询"01"课程比"02"课程成绩高的学生的信息及课程分数
## 方法一：
select stu.s_id, s_name, s_birth, s_sex
from student stu
         right join score s1 on stu.s_id = s1.s_id and s1.c_id = '01'
         right join score s2 on stu.s_id = s2.s_id and s2.c_id = '02'
where s1.s_score > s2.s_score;
## 方法二：
select a.*, b.s_score as 01_score, c.s_score as 02_score
from student a
         join score b on a.s_id = b.s_id and b.c_id = '01'
         left join score c on a.s_id = c.s_id and c.c_id = '02' or c.c_id is null
where b.s_score > c.s_score;
# 2、查询"01"课程比"02"课程成绩低的学生的信息及课程分数
## 方法一：
select stu.s_id, s_name, s_birth, s_sex, s.s_score, b.s_score
from student stu
         left join score s on stu.s_id = s.s_id and s.c_id = '01'
         right join score b on stu.s_id = b.s_id and b.c_id = '02'
where s.s_score < b.s_score;
## 方法二：
select a.*, b.s_score as 01_score, c.s_score as 02_score
from student a
         left join score b on a.s_id = b.s_id and b.c_id = '01' or b.c_id is null
         join score c on a.s_id = c.s_id and c.c_id = '02'
where b.s_score < c.s_score;
-- 3、查询平均成绩大于等于60分的同学的学生编号和学生姓名和平均成绩
select b.s_id, b.s_name, ROUND(AVG(a.s_score), 2) as avg_score
from student b
         join score a on b.s_id = a.s_id
group by b.s_id, b.s_name
having ROUND(AVG(a.s_score), 2) >= 60;
-- 4、查询平均成绩小于60分的同学的学生编号和学生姓名和平均成绩
-- (包括有成绩的和无成绩的)
select b.s_id, b.s_name, ROUND(AVG(a.s_score), 2) as avg_score
from student b
         left join score a on b.s_id = a.s_id
group by b.s_id, b.s_name
having ROUND(AVG(a.s_score), 2) < 60
union
select a.s_id, a.s_name, 0 as avg_score
from student a
where a.s_id not in (
    select distinct s_id
    from score);
-- 5、查询所有同学的学生编号、学生姓名、选课总数、所有课程的总成绩
select a.s_id, a.s_name, count(b.c_id) as sum_course, sum(b.s_score) as sum_score
from student a
         left join score b on a.s_id = b.s_id
group by a.s_id, a.s_name;
-- 6、查询"李"姓老师的数量
select count(t_id)
from teacher
where t_name like '李%';
-- 7、查询学过"张三"老师授课的同学的信息
select a.*
from student a
         join score b on a.s_id = b.s_id
where b.c_id in (
    select c_id
    from course
    where t_id = (
        select t_id
        from teacher
        where t_name = '张三'));
-- 8、查询没学过"张三"老师授课的同学的信息
select *
from student c
where c.s_id not in (
    select a.s_id
    from student a
             join score b on a.s_id = b.s_id
    where b.c_id in (
        select c_id
        from course
        where t_id = (
            select t_id
            from teacher
            where t_name = '张三')));
-- 9、查询学过编号为"01"并且也学过编号为"02"的课程的同学的信息
select a.*
from student a,
     score b,
     score c
where a.s_id = b.s_id
  and a.s_id = c.s_id
  and b.c_id = '01'
  and c.c_id = '02';
-- 10、查询学过编号为"01"但是没有学过编号为"02"的课程的同学的信息
select a.*
from student a
where a.s_id in (select s_id from score where c_id = '01')
  and a.s_id not in (select s_id from score where c_id = '02');
-- 11、查询没有学全所有课程的同学的信息
select s.*
from student s
where s.s_id in (
    select s_id
    from score
    where s_id not in (
        select a.s_id
        from score a
                 join score b on a.s_id = b.s_id and b.c_id = '02'
                 join score c on a.s_id = c.s_id and c.c_id = '03'
        where a.c_id = '01'));
-- 12、查询至少有一门课与学号为"01"的同学所学相同的同学的信息
select *
from student
where s_id in (
    select distinct a.s_id from score a where a.c_id in (select a.c_id from score a where a.s_id = '01')
);
-- 13、查询和"01"号的同学学习的课程完全相同的其他同学的信息
select a.*
from student a
where a.s_id in (
    select distinct s_id
    from score
    where s_id != '01'
      and c_id in (select c_id from score where s_id = '01')
    group by s_id
    having count(1) = (select count(1) from score where s_id = '01'));
-- 14、查询没学过"张三"老师讲授的任一门课程的学生姓名
select a.s_name
from student a
where a.s_id not in (
    select s_id
    from score
    where c_id =
          (select c_id
           from course
           where t_id = (
               select t_id
               from teacher
               where t_name = '张三'))
    group by s_id);
# 15、查询两门及其以上不及格课程的同学的学号，姓名及其平均成绩
## 方法1：
select stu.s_id, stu.s_name, round(avg(s.s_score), 1)
from student stu
         right join score s on stu.s_id = s.s_id
where s_score < 60
group by s.s_id
having count(1) > 1;
## 方法2：
select a.s_id, a.s_name, ROUND(AVG(b.s_score))
from student a
         left join score b on a.s_id = b.s_id
where a.s_id in (
    select s_id from score where s_score < 60 group by s_id having count(1) >= 2
)
group by a.s_id, a.s_name;
# 16、检索"01"课程分数小于60，按分数降序排列的学生信息
## 方法1：
select stu.s_id, s_name, s_birth, s_sex, s.c_id, s.s_score
from student stu
         right join score s on stu.s_id = s.s_id
where s.s_score < 60
  and s.c_id = '01'
order by s.s_score desc;
## 方法2：
select a.*, b.c_id, b.s_score
from student a,
     score b
where a.s_id = b.s_id
  and b.c_id = '01'
  and b.s_score < 60
order by b.s_score desc;
-- 17、按平均成绩从高到低显示所有学生的所有课程的成绩以及平均成绩

select stu.s_id,
       stu.s_name,
       round(avg(s.s_score))                                             as "avg_score",
       (select s_score from score where s_id = stu.s_id and c_id = '01') as chinese,
       (select s_score from score where s_id = stu.s_id and c_id = '02') as 数学,
       (select s_score from score where s_id = stu.s_id and c_id = '03') as 英语
from student stu
         right join score s on stu.s_id = s.s_id
group by stu.s_id
order by avg(s.s_score);

select a.s_id,
       (select s_score from score where s_id = a.s_id and c_id = '01') as 语文,
       (select s_score from score where s_id = a.s_id and c_id = '02') as 数学,
       (select s_score from score where s_id = a.s_id and c_id = '03') as 英语,
       round(avg(s_score), 2)                                          as 平均分
from score a
group by a.s_id
order by 平均分 desc;
-- 18.查询各科成绩最高分、最低分和平均分：以如下形式显示：课程ID，课程name，最高分，最低分，平均分，及格率，中等率，优良率，优秀率
-- 及格为>=60，中等为：70-80，优良为：80-90，优秀为：>=90

select c.c_id
     , c.c_name
     , round(avg(s.s_score), 2)
     , max(s.s_score)
     , min(s.s_score)
     , round(100 * (sum(case when s.s_score >= 60 then 1 else 0 end) /
                    sum(case when s.s_score then 1 else 0 end)),
             2) as 及格率
     , round(100 * (sum(case when s.s_score >= 70 or s.s_score < 80 then 1 else 0 end) /
                    sum(case when s.s_score then 1 else 0 end)),
             2) as 中等率
     , round(100 * (sum(case when s.s_score >= 80 or s.s_score < 90 then 1 else 0 end) /
                    sum(case when s.s_score then 1 else 0 end)),
             2) as 优良率
     , round(100 * (sum(case when s.s_score >= 90 then 1 else 0 end) /
                    sum(case when s.s_score then 1 else 0 end)),
             2) as 优秀率
from course c
         left join score s on c.c_id = s.c_id
group by c.c_id, c.c_name;

select a.c_id,
       b.c_name,
       MAX(s_score),
       MIN(s_score),
       ROUND(AVG(s_score), 2),
       ROUND(100 * (SUM(case when a.s_score >= 60 then 1 else 0 end) / SUM(case when a.s_score then 1 else 0 end)),
             2)                                                     as 及格率,
       ROUND(100 * (SUM(case when a.s_score >= 70 and a.s_score <= 80 then 1 else 0 end) /
                    SUM(case when a.s_score then 1 else 0 end)), 2) as 中等率,
       ROUND(100 * (SUM(case when a.s_score >= 80 and a.s_score <= 90 then 1 else 0 end) /
                    SUM(case when a.s_score then 1 else 0 end)), 2) as 优良率,
       ROUND(100 * (SUM(case when a.s_score >= 90 then 1 else 0 end) / SUM(case when a.s_score then 1 else 0 end)),
             2)                                                     as 优秀率
from score a
         left join course b on a.c_id = b.c_id
group by a.c_id, b.c_name;

# 19、按各科成绩进行排序，并显示排名(实现不完全)
-- mysql没有rank函数
## 方式一：
select s_id, s.c_id, s.s_score, rank
from (
         select @cid := c_id         as c_id
              , @sid := s.s_id       as s_id
              , @prevRank := s_score as s_score
              , case
                    when true
                        then @curRank := @curRank + 1
             end                     as "rank"


         from score s,
              (select @cid := null, @prevRank := null, @sid := null, @curRank := 0) p
         order by s.c_id, s.s_score desc
     ) s;

select s_id, a.c_id, s_score, rank
from (select s_id,
             c_id,
             s_score,
             case
                 when c_id = @cid
                     then @curRank := @curRank + 1
                 else @curRank := @curRank + 1
                 end as "rank",
             @cid := c_id,
             @prevRank := s_score
      from score,
           (select @cid := null, @prevRank := null, @curRank := 0) p
      order by c_id, s_score desc
     ) a;

select s_id, a.c_id, rank, s_score
from (select s_id,
             c_id,
             s_score,
             case
                 when c_id = @cid then
                     if(@prevRank = s_score, @curRank, @curRank := @curRank + 1)
                 else
                     @curRank := 1
                 end as "rank",
             @cid := c_id,
             @prevRank := s_score
      from score,
           (select @cid := null, @prevRank := null, @curRank := 0) p
      order by c_id, s_score desc
     ) a;
## 方式二：
explain
select a.s_id,

       a.c_id,
       @i := @i + 1                                             as i保留排名,
       @k := (case when @score = a.s_score then @k else @i end) as rank不保留排名,
       @score := a.s_score                                      as "sscore"
from (
         select s_id, c_id, s_score from score where c_id = '01' group by s_id, c_id, s_score order by s_score desc
     ) a,
     (select @k := 0, @i := 0, @score := 0) s
union
select a.s_id,
       a.c_id,
       @i := @i + 1                                             as i,
       @k := (case when @score = a.s_score then @k else @i end) as "rank",
       @score := a.s_score                                      as score
from (
         select s_id, c_id, s_score from score where c_id = '02' group by s_id, c_id, s_score order by s_score desc) a,
     (select @k := 0, @i := 0, @score := 0) s
union
select a.s_id,
       a.c_id,
       @i := @i + 1                                             as i,
       @k := (case when @score = a.s_score then @k else @i end) as "rank",
       @score := a.s_score                                      as score
from (
         select s_id, c_id, s_score from score where c_id = '03' group by s_id, c_id, s_score order by s_score desc
     ) a,
     (select @k := 0, @i := 0, @score := 0) s;

# 20、查询学生的总成绩并进行排名
select @i := @i + 1 as 序号
     , s_id
     , sum_score    as 总成绩
     , @k :=
        case
            when @score = sum_score
                then @k
            else @i
            end     as 排名
from (select s.s_id
           , sum(s.s_score) as sum_score
      from score s
      group by s.s_id
      order by sum_score desc) a,
     (select @i := 0
           , @k := 0
           , @score := 0) b;
# 21、查询不同老师所教不同课程平均分从高到低显示
## 方式一：
explain
select t.t_id, t.t_name, s.c_id, s.avg_score
from teacher t
         right join course c on t.t_id = c.t_id
         right join (
    select s.c_id
         , round(avg(s.s_score), 2) avg_score
    from score s
    group by s.c_id
    order by avg_score desc) s
                    on c.c_id = s.c_id;
## 方式二：(效率更高的样子)
explain
select t.t_id
     , t.t_name
     , c.c_id
     , round(avg(s.s_score), 2) as avg_score
from course c
         left join teacher t on t.t_id = c.t_id
         left join score s on c.c_id = s.c_id
group by c.c_id, c.t_id
order by avg_score desc;
# 22、查询所有课程的成绩第2名到第3名的学生信息及该课程成绩
## 方式1
explain
select c.c_id, c.c_name, stu.s_name, s.score, rank
from (select s.s_id              as s_id
           , s.c_id              as c_id
           , @score := s.s_score as score
           , case
                 when @cid = s.c_id
                     then @i := @i + 1
                 else @i := 1
        end                      as "rank"
           , @cid := s.c_id
      from (select @k := 0, @i := 0, @score := 0, @cid := null) p
         , score s
      order by s.c_id, s.s_score
          desc) s
         left join course c on s.c_id = c.c_id
         left join student stu on s.s_id = stu.s_id
where rank in (2, 3);
## 方式2
explain
select d.*, c.排名, c.s_score, c.c_id
from (
         select a.s_id, a.s_score, a.c_id, @i := @i + 1 as 排名
         from score a,
              (select @i := 0) s
         where a.c_id = '01'
     ) c
         left join student d on c.s_id = d.s_id
where 排名 between 2 and 3
union
select d.*, c.排名, c.s_score, c.c_id
from (
         select a.s_id, a.s_score, a.c_id, @j := @j + 1 as 排名
         from score a,
              (select @j := 0) s
         where a.c_id = '02'
     ) c
         left join student d on c.s_id = d.s_id
where 排名 between 2 and 3
union
select d.*, c.排名, c.s_score, c.c_id
from (
         select a.s_id, a.s_score, a.c_id, @k := @k + 1 as 排名
         from score a,
              (select @k := 0) s
         where a.c_id = '03'
     ) c
         left join student d on c.s_id = d.s_id
where 排名 between 2 and 3;

# 23、统计各科成绩各分数段人数：课程编号,课程名称,[100-85],[85-70],[70-60],[0-60]及所占百分比
select @count := @count + 1,
       @score := s.s_score,
       case
           when @cid = s.c_id
               then if(@score > 85 and @score <= 100,
                       @count100 := @count100 + 1,
                       if(@score > 70 and @score <= 85,
                          @count85 := @count85 + 1,
                          if(@score > 60 and @score <= 70,
                             @count70 := @count70 + 1,
                             @count60 := @count60 + 1
                              )
                           ))
           else @count100 := 0
               and @count85 := 0
               and @count70 := 0
               and @count60 := 0
               and if(@score > 85 and @score <= 100,
                      @count100 := @count100 + 1,
                      if(@score > 70 and @score <= 85,
                         @count85 := @count85 + 1,
                         if(@score >= 60 and @score <= 70,
                            @count70 := @count70 + 1,
                            @count60 := @count60 + 1
                             )
                          ))
           end as aaa,
       @cid := s.c_id,
       @count,
       @count100,
       @count85,
       @count70,
       @count60
from score s
   , (
    select @count := 0
         , @count100 := 0
         , @count85 := 0
         , @count70 := 0
         , @count60 := 0
         , @cid := null
         , @score := null
) p
order by s.c_id;

select distinct f.c_name,
                a.c_id,
                b.`85-100`,
                b.百分比,
                c.`70-85`,
                c.百分比,
                d.`60-70`,
                d.百分比,
                e.`0-60`,
                e.百分比
from score a
         left join (select c_id,
                           SUM(case when s_score > 85 and s_score <= 100 then 1 else 0 end) as `85-100`,
                           ROUND(100 * (SUM(case when s_score > 85 and s_score <= 100 then 1 else 0 end) / count(*)),
                                 2)                                                         as 百分比
                    from score
                    group by c_id) b
                   on a.c_id = b.c_id

         left join (select c_id,
                           SUM(case when s_score > 70 and s_score <= 85 then 1 else 0 end) as `70-85`,
                           ROUND(100 * (SUM(case when s_score > 70 and s_score <= 85 then 1 else 0 end) / count(*)),
                                 2)                                                        as 百分比
                    from score
                    group by c_id) c
                   on a.c_id = c.c_id

         left join (select c_id,
                           SUM(case when s_score > 60 and s_score <= 70 then 1 else 0 end) as `60-70`,
                           ROUND(100 * (SUM(case when s_score > 60 and s_score <= 70 then 1 else 0 end) / count(*)),
                                 2)                                                        as 百分比
                    from score
                    group by c_id) d
                   on a.c_id = d.c_id

         left join (select c_id,
                           SUM(case when s_score >= 0 and s_score <= 60 then 1 else 0 end) as `0-60`,
                           ROUND(100 * (SUM(case when s_score >= 0 and s_score <= 60 then 1 else 0 end) / count(*)),
                                 2)                                                        as 百分比
                    from score
                    group by c_id) e
                   on a.c_id = e.c_id

         left join course f
                   on a.c_id = f.c_id;
# 24、查询学生平均成绩及其名次
## 方式1
select @k := @k + 1, s.s_id, s.avg_score, @i := @i + 1
from (select s_id, round(avg(s_score), 2) as avg_score
      from score
      group by s_id
      order by avg_score desc
     ) s,
     (select @k := 0, @i := 0) p;
## 方式2
select a.s_id,
       @i := @i + 1                                               as '不保留空缺排名',
       @k := (case when @avg_score = a.avg_s then @k else @i end) as '保留空缺排名',
       @avg_score := avg_s                                        as '平均分'
from (select s_id, ROUND(AVG(s_score), 2) as avg_s from score group by s_id) a,
     (select @avg_score := 0, @i := 0, @k := 0) b;
# 25、查询各科成绩前三名的记录
explain
select p.c_id, p.s_id, p.s_score, p.randk
from (select s.s_id
           , s.s_score
           , case
                 when @cid = s.c_id
                     then @i := @i + 1
                 else @i := 1
        end                 as "randk"
           , @cid := s.c_id as c_id
      from score s
         , (select @i := 0, @cid := null) p
      order by s.c_id, s.s_score desc) p
where p.randk < 4;

explain
select s.s_id
     , s.c_id
     , s.s_score
from score s
         left join score b on s.c_id = b.c_id and s.s_score < b.s_score
group by s.s_id, s.c_id
having COUNT(s.c_id) < 3
order by s.c_id, s.s_score desc;

## 1.选出b表比a表成绩大的所有组

## 2.选出比当前id成绩大的 小于三个的
select a.s_id, a.c_id, a.s_score
from score a
         left join score b on a.c_id = b.c_id and a.s_score < b.s_score
group by a.s_id, a.c_id, a.s_score
having COUNT(b.s_id) < 3
order by a.c_id, a.s_score desc;
-- 26、查询每门课程被选修的学生数
select c_id, count(s_id)
from score a
group by c_id;
-- 27、查询出只有两门课程的全部学生的学号和姓名
select s_id, s_name
from student
where s_id in (
    select s_id
    from score
    group by s_id
    having COUNT(c_id) = 2);
-- 28、查询男生、女生人数
select s_sex, COUNT(s_sex) as 人数
from student
group by s_sex;
-- 29、查询名字中含有"风"字的学生信息
select *
from student
where s_name like '%风%';
-- 30、查询同名同性学生名单，并统计同名人数
select a.s_name, a.s_sex, count(*)
from student a
         join
     student b on a.s_id != b.s_id and a.s_name = b.s_name and a.s_sex = b.s_sex
group by a.s_name, a.s_sex;
-- 31、查询1990年出生的学生名单
select s_name
from student
where s_birth like '1990%';
-- 32、查询每门课程的平均成绩，结果按平均成绩降序排列，平均成绩相同时，按课程编号升序排列

select c_id, ROUND(AVG(s_score), 2) as avg_score
from score
group by c_id
order by avg_score desc, c_id asc;
-- 33、查询平均成绩大于等于85的所有学生的学号、姓名和平均成绩

select a.s_id, b.s_name, ROUND(avg(a.s_score), 2) as avg_score
from score a
         left join student b on a.s_id = b.s_id
group by s_id
having avg_score >= 85;
-- 34、查询课程名称为"数学"，且分数低于60的学生姓名和分数

select a.s_name, b.s_score
from score b
         left join student a on a.s_id = b.s_id
where b.c_id = (
    select c_id
    from course
    where c_name = '数学')
  and b.s_score < 60;
-- 35、查询所有学生的课程及分数情况；
select a.s_id,
       a.s_name,
       SUM(case c.c_name when '语文' then b.s_score else 0 end) as '语文',
       SUM(case c.c_name when '数学' then b.s_score else 0 end) as '数学',
       SUM(case c.c_name when '英语' then b.s_score else 0 end) as '英语',
       SUM(b.s_score)                                         as '总分'
from student a
         left join score b on a.s_id = b.s_id
         left join course c on b.c_id = c.c_id
group by a.s_id, a.s_name;
-- 36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；
select a.s_name, b.c_name, c.s_score
from course b
         left join score c on b.c_id = c.c_id
         left join student a on a.s_id = c.s_id
where c.s_score >= 70;
-- 37、查询不及格的课程
select a.s_id, a.c_id, b.c_name, a.s_score
from score a
         left join course b on a.c_id = b.c_id
where a.s_score < 60;
-- 38、查询课程编号为01且课程成绩在80分以上的学生的学号和姓名；
select a.s_id, b.s_name
from score a
         left join student b on a.s_id = b.s_id
where a.c_id = '01'
  and a.s_score > 80;
-- 39、求每门课程的学生人数
select count(*)
from score
group by c_id;
-- 40、查询选修"张三"老师所授课程的学生中，成绩最高的学生信息及其成绩
-- 查询老师id
select c_id
from course c,
     teacher d
where c.t_id = d.t_id
  and d.t_name = '张三';
-- 查询最高分（可能有相同分数）
select MAX(s_score)
from score
where c_id = '02';
-- 查询信息
select a.*, b.s_score, b.c_id, c.c_name
from student a
         left join score b on a.s_id = b.s_id
         left join course c on b.c_id = c.c_id
where b.c_id = (select c_id
                from course c,
                     teacher d
                where c.t_id = d.t_id
                  and d.t_name = '张三')
  and b.s_score in (select MAX(s_score) from score where c_id = '02');
-- 41、查询不同课程成绩相同的学生的学生编号、课程编号、学生成绩
select distinct b.s_id, b.c_id, b.s_score
from score a,
     score b
where a.c_id != b.c_id
  and a.s_score = b.s_score;
-- 42、查询每门功成绩最好的前两名
-- 牛逼的写法
select a.s_id, a.c_id, a.s_score
from score a
where (select COUNT(1) from score b where b.c_id = a.c_id and b.s_score >= a.s_score) <= 2
order by a.c_id;
-- 43、统计每门课程的学生选修人数（超过5人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，若人数相同，按课程号升序排列
select c_id, count(*) as total
from score
group by c_id
having total > 5
order by total, c_id asc;
-- 44、检索至少选修两门课程的学生学号
select s_id, count(*) as sel
from score
group by s_id
having sel >= 2;

-- 45、查询选修了全部课程的学生信息
select *
from student
where s_id in (
    select s_id from score group by s_id having count(*) = (select count(*) from course));

-- 46、查询各学生的年龄
-- 按照出生日期来算，当前月日 < 出生年月的月日则，年龄减一
select s_birth,
       (DATE_FORMAT(NOW(), '%Y') - DATE_FORMAT(s_birth, '%Y') -
        (case when DATE_FORMAT(NOW(), '%m%d') > DATE_FORMAT(s_birth, '%m%d') then 0 else 1 end)) as age
from student;
-- 47、查询本周过生日的学生
select *
from student
where WEEK(DATE_FORMAT(NOW(), '%Y%m%d')) = WEEK(s_birth);
select *
from student
where YEARWEEK(s_birth) = YEARWEEK(DATE_FORMAT(NOW(), '%Y%m%d'));
select WEEK(DATE_FORMAT(NOW(), '%Y%m%d'));
-- 48、查询下周过生日的学生
select *
from student
where WEEK(DATE_FORMAT(NOW(), '%Y%m%d')) + 1 = WEEK(s_birth);
-- 49、查询本月过生日的学生
select *
from student
where MONTH(DATE_FORMAT(NOW(), '%Y%m%d')) = MONTH(s_birth);
-- 50、查询下月过生日的学生
select *
from student
where MONTH(DATE_FORMAT(NOW(), '%Y%m%d')) + 1 = MONTH(s_birth);